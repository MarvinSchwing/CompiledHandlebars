@namespace CompiledHandlebars.Compiler
@classname HbsParser
@using CompiledHandlebars.Compiler.AST
@using CompiledHandlebars.Compiler.AST.Expressions

@using System.Linq
@members
{
    private static void AddError(string message, HandlebarsSyntaxErrorKind kind, Cursor state)
    {
        var existing = state["errors"] as IList<HandlebarsSyntaxError>;
        var newList = existing == null ? new List<HandlebarsSyntaxError>() : existing.ToList();
        newList.Add(new HandlebarsSyntaxError(        
            message,
            kind,
            state.Line,
            state.Column           
        ));
        state["errors"] = newList.AsReadOnly();
    }
}

Template<HandlebarsTemplate> 
    = model:ModelNode items:Element EOF {new HandlebarsTemplate(items, model, state["errors"] as IList<HandlebarsSyntaxError>)}

ModelNode <MemberExpression>
    = Opening ModelKeyword value:MemberExpression Closing { value }
    / v:Opening ModelKeyword (!Closing .)* Closing #STATE{ AddError("Malformed ModelToken. Syntax is: {{model MemberExpression}}", HandlebarsSyntaxErrorKind.MalformedModelToken, state); } { default(MemberExpression)}
    / v:.* #STATE{ AddError("ModelToken is expected as first Token of a Handlebars-Template", HandlebarsSyntaxErrorKind.MissingModelToken, state); } { default(MemberExpression) }

//------------------------------
//        ASTElements
//------------------------------

Element 
    = (Comment
    / Node
    / Token)*

Token <ASTElementBase>
    = "{{" TrimWhitespaceIdentifier? value:ASTLeaf TrimWhitespaceIdentifier? "}}" { {value.SetTokenType(TokenType.Encoded); return value;} }
    / "{{{" TrimWhitespaceIdentifier? value:ASTLeaf TrimWhitespaceIdentifier? "}}}" { {value.SetTokenType(TokenType.Escaped); return value;} }
    / MarkupLiteral

ASTLeaf <ASTElementBase>
    = PartialCall
    / YieldStatement

PartialCall <PartialCall>
    = PartialCallIdentifier templateName:MemberExpression member:MemberExpression { new PartialCall(templateName.ToString(), member, templateNameStart.Line, templateNameStart.Column)}
    / PartialCallIdentifier templateName:MemberExpression { new PartialCall(templateName.ToString(), templateNameStart.Line, templateNameStart.Column) }
    / v:PartialCallIdentifier (!Closing .)* #STATE{ AddError("Malformed PartialCall Token. Syntax is: {{> TemplateName}} or {{> TemplateName MemberName}}", HandlebarsSyntaxErrorKind.MalformedPartialCallToken, state); } { new PartialCall(null, vStart.Line, vStart.Column) }

YieldStatement <YieldStatement>
    = val:MemberExpression {new YieldStatement(val,valStart.Line,valStart.Column)}

MarkupLiteral <MarkupLiteral> 
    = &TrimClosing value:((!Opening !Closing .)+) &TrimOpening { new MarkupLiteral(string.Concat(value), true, true, valueStart.Line, valueStart.Column)}
    / &TrimClosing value:((!Opening !Closing .)+)  { new MarkupLiteral(string.Concat(value), true, false, valueStart.Line, valueStart.Column)}
    / value:((!Opening !Closing .)+) &TrimOpening { new MarkupLiteral(string.Concat(value), false, true, valueStart.Line, valueStart.Column)}
    / value:((!Opening !Closing .)+) { new MarkupLiteral(string.Concat(value), valueStart.Line, valueStart.Column)}

Comment <ASTElementBase>
    = MultilineCommentOpening val:(!MultilineCommentClosing .)* MultilineCommentClosing { new CommentLiteral(CommentType.Multi, string.Concat(val), valStart.Line, valStart.Column)}
    / CommentOpening val:(!CommentClosing .)* CommentClosing { new CommentLiteral(CommentType.Single, string.Concat(val), valStart.Line, valStart.Column)}
    
//-----------------------------------------------
//    Nodes and Blocks
//-----------------------------------------------

Node <ASTElementBase>
    = WithBlock
    / EachBlock
    / IfBlock
    / Opening BlockOpeningIdentifier name:(!Closing .)+ Closing #STATE{ AddError(string.Format("Unknown Block Token '{0}'!",string.Concat(name)), HandlebarsSyntaxErrorKind.UnknownBlock, state);} { new MarkupLiteral(null,0,0)}



BlockBody 
    = Element

//#With
WithBlock <WithBlock>
    = member:WithOpeningToken body:BlockBody WithClosingToken { new WithBlock(member, body, memberStart.Line, memberStart.Column )}
    / member:WithOpeningToken body:BlockBody #STATE{ AddError("Missing '{{/with}}' for {{#with}}", HandlebarsSyntaxErrorKind.MalformedBlock, state); } { new WithBlock(null, null, 0, 0)}   

WithOpeningToken <MemberExpression>
    = Opening BlockOpeningIdentifier WithKeyword val:MemberExpression Closing { val }
    / Opening BlockOpeningIdentifier WithKeyword v:(!Closing .)* Closing #STATE{ AddError("Missing MemberExpression in #with Token. Syntax: {{#with MemberExpression}}", HandlebarsSyntaxErrorKind.MissingMemberExpression, state ); } { new MemberExpression(null)}

WithClosingToken
    = Opening BlockClosingIdentifier WithKeyword Closing

//#Each
EachBlock <EachBlock>
    = member:EachOpeningToken body:BlockBody EachClosingToken {new EachBlock(member, body, memberStart.Line, memberStart.Column)}

EachOpeningToken <MemberExpression>
    = Opening BlockOpeningIdentifier EachKeyword member:MemberExpression Closing { member }

EachClosingToken
    = Opening BlockClosingIdentifier EachKeyword Closing


//#If
IfBlock <IfBlock>
  = member:IfOpeningToken body:BlockBody ElseToken elseBlock:BlockBody IfClosingToken { new IfBlock(member, IfType.If, elseBlock, body, memberStart.Line, memberStart.Column) }
  / member:UnlessOpeningToken body:BlockBody ElseToken elseBlock:BlockBody UnlessClosingToken { new IfBlock(member, IfType.Unless, elseBlock, body, memberStart.Line, memberStart.Column) }
  / member:IfOpeningToken body:BlockBody IfClosingToken { new IfBlock(member, IfType.If, body, memberStart.Line, memberStart.Column) }
  / member:UnlessOpeningToken body:BlockBody UnlessClosingToken { new IfBlock(member, IfType.Unless, body, memberStart.Line, memberStart.Column) }

IfOpeningToken <MemberExpression>
  = Opening BlockOpeningIdentifier IfKeyword member:MemberExpression Closing { member }

IfClosingToken
  = Opening BlockClosingIdentifier IfKeyword Closing

UnlessOpeningToken <MemberExpression>
  = Opening BlockOpeningIdentifier UnlessKeyword member:MemberExpression Closing { member }

UnlessClosingToken
  = Opening BlockClosingIdentifier UnlessKeyword Closing

ElseToken
  = Opening ElseKeyword Closing


//-----------------------------------------------
//    Expressions, Statements
//-----------------------------------------------

MemberExpression <MemberExpression>
    = Whitespace value:(ThisBasedPath/MemberPath) Whitespace { new MemberExpression(value)}

MemberPath     
    = NestedMemberIdentifier
    / MemberIdentifier

ThisBasedPath<IdentifierElement> 
    = ThisKeyword NameDelimiter next:MemberPath { new ThisIdentifier(next)}
    / ThisKeyword { new ThisIdentifier(null) }

//Last Identifier Element => no next
MemberIdentifier <IdentifierElement>
    = value:NameIdentifier {new Identifier(value, null)}

NestedMemberIdentifier
    = ParentContextName
    / ChildContextName

ParentContextName <IdentifierElement>
    = ParentPathLiteral next:MemberPath {new PathUp(next)}

ChildContextName <IdentifierElement>
    = value:NameIdentifier NameDelimiter next:MemberPath {new Identifier(value, next)}
    / value:NameIdentifier NameDelimiter (NameDelimiter)+ MemberPath #STATE{ AddError("Malformed MemberExpression: multiple identifier delimiter!", HandlebarsSyntaxErrorKind.MalformedMemberExpression, state);} { new Identifier(null, null)}
    / value:NameIdentifier NameDelimiter #STATE{ AddError("Malformed MemberExpression: identifier delimiter without subsequent identifier!", HandlebarsSyntaxErrorKind.MalformedMemberExpression,  state);} { new Identifier(null, null)}
      

NameIdentifier <string>
    = (!ReservedKeywords) val:Identifier {string.Concat(val)}

Identifier
    = ([a-z]i / [0-9] / "_" )+

//-------------------------------
//      Keywords and Literals
//-------------------------------

/*
PrecedingTrimWhitespace
    = #STATE{state.Advance(-3); } "~}}"
    / #STATE{state.Advance(-4); } "~}}}"
    / #STATE{state.Advance(-5); } "~}}}}"
*/

ReservedKeywords 
  = ElseKeyword
  
PartialCallIdentifier = ">"
BlockOpeningIdentifier = "#"
BlockClosingIdentifier = "/"
TrimWhitespaceIdentifier = "~"
WithKeyword = "with"
EachKeyword = "each"
IfKeyword = "if"
UnlessKeyword = "unless"
ElseKeyword = "else"
ModelKeyword = "model"
Opening = ("{{"/"{{{"/"{{{{")TrimWhitespaceIdentifier?
Closing = TrimWhitespaceIdentifier?("}}"/"}}}"/"}}}}")
TrimOpening = ("{{"/"{{{"/"{{{{")TrimWhitespaceIdentifier
TrimClosing = TrimWhitespaceIdentifier("}}"/"}}}"/"}}}}")
CommentOpening = "{{!"
CommentClosing = "}}"
MultilineCommentOpening = "{{!--"
MultilineCommentClosing = "--}}"
ParentPathLiteral = "../"
NameDelimiter = "." / "/"
Whitespace = " "*
ThisKeyword = "this" / ("."!".")


//-------------------------------
//      Miscellaneous
//-------------------------------

EOF 
  = !.
  / c:. 