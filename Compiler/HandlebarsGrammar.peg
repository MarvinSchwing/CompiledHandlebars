@namespace CompiledHandlebars.Compiler
@classname HbsParser
@using CompiledHandlebars.Compiler.AST
@using CompiledHandlebars.Compiler.AST.Expressions

@using System.Linq
@members
{
    private static void AddError(string message, HandlebarsSyntaxErrorKind kind, Cursor state)
    {
        var existing = state["errors"] as IList<HandlebarsSyntaxError>;
        var newList = existing == null ? new List<HandlebarsSyntaxError>() : existing.ToList();
        newList.Add(new HandlebarsSyntaxError(        
            message,
            kind,
            state.Line,
            state.Column           
        ));
        state["errors"] = newList.AsReadOnly();
    }
}

Template<HandlebarsTemplate> 
    = model:ModelToken items:(Element*) EOF {new HandlebarsTemplate(items, model, state["errors"] as IList<HandlebarsSyntaxError>)}

ModelToken <MemberExpression>
    = Opening ModelKeyword value:MemberExpression Closing { value }
    / v:Opening ModelKeyword (!Closing .)* Closing #STATE{ AddError("Malformed ModelToken. Syntax is: {{model MemberExpression}}", HandlebarsSyntaxErrorKind.MalformedModelToken, state); } { default(MemberExpression)}
    / v:.* #STATE{ AddError("ModelToken is expected as first Token of a Handlebars-Template", HandlebarsSyntaxErrorKind.MissingModelToken, state); } { default(MemberExpression) }

//------------------------------
//        ASTElements
//------------------------------

Element 
    = Node / Leaf

Leaf <ASTElementBase>
    = Opening value:HandlebarsLeaf Closing { value }
    / EscapedOpening TrimWhitespaceIdentifier? value:YieldStatement EscapedClosing { {value.SetTokenType(TokenType.Escaped); return value;} }
    / MarkupLiteral

HandlebarsLeaf <ASTElementBase>
    = CommentIdentifier val:Comment { val }
    / PartialCallIdentifier val:PartialCall { val } 
    / YieldStatement

PartialCall <PartialCall>
    = templateName:MemberExpression member:MemberExpression { new PartialCall(templateName.ToString(), member, templateNameStart.Line, templateNameStart.Column)}
    / templateName:MemberExpression { new PartialCall(templateName.ToString(), templateNameStart.Line, templateNameStart.Column) }
    / v:(!Closing .)* #STATE{ AddError("Malformed PartialCall Token. Syntax is: {{> TemplateName}} or {{> TemplateName MemberName}}", HandlebarsSyntaxErrorKind.MalformedPartialCallToken, state); } { new PartialCall(null, vStart.Line, vStart.Column) }

YieldStatement <YieldStatement>
    = val:Expression {new YieldStatement(val,valStart.Line,valStart.Column)}

MarkupLiteral <MarkupLiteral> 
    = &{ state["trimStart"]==true}value:((!Opening !Closing .)+) &TrimOpening #STATE{ state["trimStart"]=false; } { new MarkupLiteral(string.Concat(value), true, true, valueStart.Line, valueStart.Column)}
    / &{ state["trimStart"]==true} value:((!Opening !Closing .)+) #STATE{ state["trimStart"]=false; } { new MarkupLiteral(string.Concat(value), true, false, valueStart.Line, valueStart.Column)}
    / value:((!Opening !Closing .)+) &TrimOpening { new MarkupLiteral(string.Concat(value), false, true, valueStart.Line, valueStart.Column)}
    / value:((!Opening !Closing .)+) { new MarkupLiteral(string.Concat(value), valueStart.Line, valueStart.Column)}

Comment <ASTElementBase>
    = "--" val:(!MultilineCommentClosing .)* "--" { new CommentLiteral(CommentType.Multi, string.Concat(val), valStart.Line, valStart.Column)}
    / val:(!Closing .)* { new CommentLiteral(CommentType.Single, string.Concat(val), valStart.Line, valStart.Column)}
    
//-----------------------------------------------
//    Nodes and Blocks
//-----------------------------------------------

Node <ASTElementBase>
    = WithBlock
    / EachBlock
    / IfBlock
    / Opening BlockOpeningIdentifier name:(!Closing .)+ Closing #STATE{ AddError(string.Format("Unknown Block Token '{0}'!",string.Concat(name)), HandlebarsSyntaxErrorKind.UnknownBlock, state);} { new MarkupLiteral(null,0,0)}

BlockBody 
    = Element*

//#With
WithBlock <WithBlock>
    = member:WithOpeningToken body:BlockBody WithClosingToken { new WithBlock(member, body, memberStart.Line, memberStart.Column )}
    / member:WithOpeningToken body:BlockBody #STATE{ AddError("Missing '{{/with}}' for {{#with}}", HandlebarsSyntaxErrorKind.MalformedBlock, state); } { new WithBlock(null, null, 0, 0)}   

WithOpeningToken <MemberExpression>
    = Opening BlockOpeningIdentifier WithKeyword val:MemberExpression Closing { val }
    / Opening BlockOpeningIdentifier WithKeyword v:(!Closing .)* Closing #STATE{ AddError("Missing MemberExpression in #with Token. Syntax: {{#with MemberExpression}}", HandlebarsSyntaxErrorKind.MissingMemberExpression, state ); } { new MemberExpression(null)}

WithClosingToken
    = Opening BlockClosingIdentifier WithKeyword Closing

//#Each
EachBlock <EachBlock>
    = member:EachOpeningToken body:BlockBody EachClosingToken {new EachBlock(member, body, memberStart.Line, memberStart.Column)}

EachOpeningToken <MemberExpression>
    = Opening BlockOpeningIdentifier EachKeyword member:MemberExpression Closing { member }

EachClosingToken
    = Opening BlockClosingIdentifier EachKeyword Closing


//#If
IfBlock <IfBlock>
  = expr:IfOpeningToken body:BlockBody ElseToken elseBlock:BlockBody IfClosingToken { new IfBlock(expr, IfType.If, elseBlock, body, exprStart.Line, exprStart.Column) }
  / expr:UnlessOpeningToken body:BlockBody ElseToken elseBlock:BlockBody UnlessClosingToken { new IfBlock(expr, IfType.Unless, elseBlock, body, exprStart.Line, exprStart.Column) }
  / expr:IfOpeningToken body:BlockBody IfClosingToken { new IfBlock(expr, IfType.If, body, exprStart.Line, exprStart.Column) }
  / expr:UnlessOpeningToken body:BlockBody UnlessClosingToken { new IfBlock(expr, IfType.Unless, body, exprStart.Line, exprStart.Column) }

IfOpeningToken <Expression>
  = Opening BlockOpeningIdentifier IfKeyword expr:Expression Closing { expr }

IfClosingToken
  = Opening BlockClosingIdentifier IfKeyword Closing

UnlessOpeningToken <Expression>
  = Opening BlockOpeningIdentifier UnlessKeyword expr:Expression Closing { expr }

UnlessClosingToken
  = Opening BlockClosingIdentifier UnlessKeyword Closing

ElseToken
  = Opening ElseKeyword Closing


//-----------------------------------------------
//    Expressions, Statements
//-----------------------------------------------

Expression <Expression>
    = FirstExpression
    / LastExpression
    / IndexExpression
    / MemberExpression

IndexExpression <IndexExpression>
    = Whitespace IndexKeyword { new IndexExpression() }

FirstExpression <FirstExpression>
    = Whitespace FirstKeyword { new FirstExpression() }

LastExpression <LastExpression>
    = Whitespace LastKeyword { new LastExpression() }

MemberExpression <MemberExpression>
    = Whitespace value:(SpecialPath/MemberPath) Whitespace { new MemberExpression(value)}

MemberPath     
    = NestedMemberIdentifier
    / MemberIdentifier

SpecialPath
    = ThisBasedPath
    / RootBasedPath

RootBasedPath<IdentifierElement> 
    = RootKeyword NameDelimiter next:MemberPath { new RootIdentifier(next)}
    / RootKeyword { new RootIdentifier(null) }

ThisBasedPath<IdentifierElement> 
    = ThisKeyword NameDelimiter next:MemberPath { new ThisIdentifier(next)}
    / ThisKeyword { new ThisIdentifier(null) }

//Last Identifier Element => no next
MemberIdentifier <IdentifierElement>
    = value:NameIdentifier {new Identifier(value, null)}

NestedMemberIdentifier
    = ParentContextName
    / ChildContextName

ParentContextName <IdentifierElement>
    = ParentPathLiteral next:MemberPath {new PathUp(next)}

ChildContextName <IdentifierElement>
    = value:NameIdentifier NameDelimiter next:MemberPath {new Identifier(value, next)}
    / value:NameIdentifier NameDelimiter (NameDelimiter)+ MemberPath #STATE{ AddError("Malformed MemberExpression: multiple identifier delimiter!", HandlebarsSyntaxErrorKind.MalformedMemberExpression, state);} { new Identifier(null, null)}
    / value:NameIdentifier NameDelimiter #STATE{ AddError("Malformed MemberExpression: identifier delimiter without subsequent identifier!", HandlebarsSyntaxErrorKind.MalformedMemberExpression,  state);} { new Identifier(null, null)}
      

NameIdentifier <string>
    = (!ReservedKeywords) val:Identifier {string.Concat(val)}

Identifier
    = ([a-z]i / [0-9] / "_" )+

//-------------------------------
//      Keywords and Literals
//-------------------------------

ReservedKeywords 
  = ElseKeyword
  
PartialCallIdentifier = ">"
BlockOpeningIdentifier = "#"
BlockClosingIdentifier = "/"
TrimWhitespaceIdentifier = "~"
CommentIdentifier = "!"
WithKeyword = "with"
EachKeyword = "each"
IfKeyword = "if"
UnlessKeyword = "unless"
ElseKeyword = "else"
ModelKeyword = "model"
RootKeyword = "@root"
FirstKeyword = "@first"
LastKeyword = "@last"
IndexKeyword = "@index"
Opening = "{{"TrimWhitespaceIdentifier?
Closing = (TrimWhitespaceIdentifier #STATE{ state["trimStart"]=true; })?"}}"
EscapedOpening = "{{{"TrimWhitespaceIdentifier?
EscapedClosing = (TrimWhitespaceIdentifier #STATE{ state["trimStart"]=true; })?"}}}"
MultilineCommentClosing = (TrimWhitespaceIdentifier #STATE{ state["trimStart"]=true; })?"--}}"
TrimOpening = ("{{{{"/"{{{"/"{{")TrimWhitespaceIdentifier
ParentPathLiteral = "../"
NameDelimiter = "." / "/"
Whitespace = " "*
ThisKeyword = "this" / ("."!".")


//-------------------------------
//      Miscellaneous
//-------------------------------

EOF 
  = !.
  / c:. 