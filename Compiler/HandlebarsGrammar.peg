@namespace CompiledHandlebars.Compiler
@classname HbsParser
@using CompiledHandlebars.Compiler.AST
@using CompiledHandlebars.Compiler.AST.Expressions

Template<HandlebarsTemplate> 
    = model:ModelNode items:Element EOF {new HandlebarsTemplate(items, model)}

ModelNode <MemberExpression>
    = Opening ModelKeyword value:MemberExpression Closing { value }
    / v:Opening ModelKeyword (!Closing .)* Closing {{ throw new HandlebarsSyntaxError("Malformed ModelToken. Syntax is: {{model MemberExpression}}", vStart.Line, vStart.Column); }}
    / v:.* { { throw new HandlebarsSyntaxError("ModelToken is expected as first Token of a Handlebars-Template", vStart.Line, vStart.Column);} }

//------------------------------
//        ASTElements
//------------------------------

Element 
    = (Node
    / Token)*

Token <ASTElementBase>
    = "{{" value:ASTLeaf "}}" { {value.SetTokenType(TokenType.Encoded); return value;} }
    / "{{{" value:ASTLeaf "}}}" { {value.SetTokenType(TokenType.Encoded); return value;} }
    / MarkupLiteral

ASTLeaf <ASTElementBase>
    = YieldStatement


YieldStatement <YieldStatement>
    = val:MemberExpression {new YieldStatement(val,valStart.Line,valStart.Column)}

MarkupLiteral <MarkupLiteral> 
    = value:((!Opening !Closing .)+) { new MarkupLiteral(string.Concat(value), valueStart.Line, valueStart.Column)}

    
//-----------------------------------------------
//    Nodes and Blocks
//-----------------------------------------------

Node <ASTElementBase>
    = WithBlock
    / IfBlock
    / Opening BlockOpeningIdentifier name:(!Closing .)+ Closing {{ throw new HandlebarsSyntaxError(string.Format("Unknown Block Token '{0}'!",name), nameStart.Line, nameStart.Column);}}



BlockBody 
    = Element

//#With
WithBlock <WithBlock>
    = member:WithOpeningToken body:BlockBody WithClosingToken { new WithBlock(member, body, memberStart.Line, memberStart.Column )}
    / member:WithOpeningToken body:BlockBody {{ throw new HandlebarsSyntaxError("Missing '{{/with}}' for {{#with}}", memberStart.Line, memberStart.Column); }}   

WithOpeningToken <MemberExpression>
    = "{{" BlockOpeningIdentifier WithKeyword val:MemberExpression "}}" { val }
    / "{{" BlockOpeningIdentifier WithKeyword v:(!Closing .)* "}}" {{ throw new HandlebarsSyntaxError("Missing MemberExpression in #with Token. Syntax: {{#with MemberExpression}}", vStart.Line, vStart.Column ); }}

WithClosingToken
    = "{{" BlockClosingIdentifier WithKeyword "}}"

//#If

IfBlock <IfBlock>
  = member:IfOpeningToken body:BlockBody ElseToken elseBlock:BlockBody IfClosingToken { new IfBlock(member, IfType.If, elseBlock, body, memberStart.Line, memberStart.Column) }
  / member:UnlessOpeningToken body:BlockBody ElseToken elseBlock:BlockBody UnlessClosingToken { new IfBlock(member, IfType.Unless, elseBlock, body, memberStart.Line, memberStart.Column) }
  / member:IfOpeningToken body:BlockBody IfClosingToken { new IfBlock(member, IfType.If, body, memberStart.Line, memberStart.Column) }
  / member:UnlessOpeningToken body:BlockBody UnlessClosingToken { new IfBlock(member, IfType.Unless, body, memberStart.Line, memberStart.Column) }

IfOpeningToken <MemberExpression>
  = "{{" BlockOpeningIdentifier IfKeyword member:MemberExpression "}}" { member }

IfClosingToken
  = "{{" BlockClosingIdentifier IfKeyword "}}"

UnlessOpeningToken <MemberExpression>
  = "{{" BlockOpeningIdentifier UnlessKeyword member:MemberExpression "}}" { member }

UnlessClosingToken
  = "{{" BlockClosingIdentifier UnlessKeyword "}}"

ElseToken
  = Opening ElseKeyword Closing


//-----------------------------------------------
//    Expressions, Statements
//-----------------------------------------------

MemberExpression <MemberExpression>
    = Whitespace value:MemberPath Whitespace { new MemberExpression(value)}

MemberPath
    = NestedMemberIdentifier
    / MemberIdentifier

//Last Identifier Element => no next
MemberIdentifier <IdentifierElement>
    = value:NameIdentifier {new Identifier(value, null)}

NestedMemberIdentifier
    = ParentContextName
    / ChildContextName

ParentContextName <IdentifierElement>
    = ParentPathLiteral next:MemberPath {new PathUp(next)}

ChildContextName <IdentifierElement>
    = value:NameIdentifier NameDelimiter next:MemberPath {new Identifier(value, next)}
    / value:NameIdentifier NameDelimiter NameDelimiter . 
      {{throw new HandlebarsSyntaxError("Malformed MemberExpression: double identifier delimiter!", valueStart.Line, valueStart.Column);}}
    / value:NameIdentifier NameDelimiter . 
      {{throw new HandlebarsSyntaxError("Malformed MemberExpression: identifier delimiter without subsequent identifier!", valueStart.Line, valueStart.Column);}}
      

NameIdentifier <string>
    = (!ReservedKeywords) val:Identifier {string.Concat(val)}

Identifier
    = [a-z]i+

//-------------------------------
//      Keywords and Literals
//-------------------------------

ReservedKeywords 
  = ElseKeyword
  

BlockOpeningIdentifier = "#"
BlockClosingIdentifier = "/"
WithKeyword = "with"
IfKeyword = "if"
UnlessKeyword = "unless"
ElseKeyword = "else"
ModelKeyword = "model"
Opening = "{{"/"{{{"/"{{{{"
Closing = "}}"/"}}}"/"}}}}"
ParentPathLiteral = "../"
NameDelimiter = "." / "/"
Whitespace = " "*


//-------------------------------
//      Miscellaneous
//-------------------------------

EOF 
  = !.
  / c:. #ERROR{ string.Format("Line {0}; Column{1}: Unexpected character {2}", cStart.Line, cStart.Column ,c) }