@namespace CompiledHandlebars.Compiler
@classname HbsParser
@using CompiledHandlebars.Compiler.AST
@using CompiledHandlebars.Compiler.AST.Expressions

Template<HandlebarsTemplate> 
    = model:ModelNode items:Element EOF {new HandlebarsTemplate(items, model)}

ModelNode <MemberExpression>
    = Opening ModelKeyword value:MemberExpression Closing { value }
    / v:Opening ModelKeyword (!Closing .)* Closing {{ throw new HandlebarsSyntaxError("Malformed ModelToken. Syntax is: {{model MemberExpression}}", vStart.Line, vStart.Column); }}
    / v:.* { { throw new HandlebarsSyntaxError("ModelToken is expected as first Token of a Handlebars-Template", vStart.Line, vStart.Column);} }

//------------------------------
//        ASTElements
//------------------------------

Element 
    = (Token)*

Token <ASTElementBase>
    = "{{" value:ASTLeaf "}}" { {value.SetTokenType(TokenType.Encoded); return value;} }
    / "{{{" value:ASTLeaf "}}}" { {value.SetTokenType(TokenType.Encoded); return value;} }
    / MarkupLiteral

ASTLeaf <ASTElementBase>
    = YieldStatement


YieldStatement <YieldStatement>
    = val:MemberExpression {new YieldStatement(val,valStart.Line,valStart.Column)}

MarkupLiteral <MarkupLiteral> 
    = value:((!Opening !Closing .)+) { new MarkupLiteral(string.Concat(value), valueStart.Line, valueStart.Column)}

    
//-----------------------------------------------
//    Nodes and Blocks
//-----------------------------------------------
/*
HandlebarsNode <ASTElement>
    = WithBlock

WithBlock <WithBlock>
    = member:WithOpeningToken body:BlockBody WithClosingToken { new WithBlock(memberStart.Line, memberStart.Column, body, member)}

WithOpeningToken <MemberExpression>
    = "{{" BlockOpeningIdentifier WithKeyword val:MemberExpression "}}" { val }

WithClosingToken
    = "{{" BlockClosingIdentifier WithKeyword "}}"

BlockBody 
    = Token

*/

//-----------------------------------------------
//    Expressions, Statements
//-----------------------------------------------

MemberExpression <MemberExpression>
    = Whitespace value:MemberPath Whitespace { new MemberExpression(value)}

MemberPath
    = NestedMemberIdentifier
    / MemberIdentifier

//Last Identifier Element => no next
MemberIdentifier <IdentifierElement>
    = value:NameIdentifier {new Identifier(value, null)}

NestedMemberIdentifier
    = ParentContextName
    / ChildContextName

ParentContextName <IdentifierElement>
    = ParentPathLiteral next:MemberPath {new PathUp(next)}

ChildContextName <IdentifierElement>
    = value:NameIdentifier NameDelimiter next:MemberPath {new Identifier(value, next)}
    / value:NameIdentifier NameDelimiter NameDelimiter . 
      {{throw new HandlebarsSyntaxError("Malformed MemberExpression: double identifier delimiter!", valueStart.Line, valueStart.Column);}}
    / value:NameIdentifier NameDelimiter . 
      {{throw new HandlebarsSyntaxError("Malformed MemberExpression: identifier delimiter without subsequent identifier!", valueStart.Line, valueStart.Column);}}
      

NameIdentifier <string>
    = val:Identifier {string.Concat(val)}

Identifier
    = [a-z]i+

//-------------------------------
//      Keywords and Literals
//-------------------------------

BlockOpeningIdentifier = "#"
BlockClosingIdentifier = "/"
WithKeyword = "with"
ModelKeyword = "model"
Opening = "{{"/"{{{"/"{{{{"
Closing = "}}"/"}}}"/"}}}}"
ParentPathLiteral = "../"
NameDelimiter = "." / "/"
Whitespace = " "*


//-------------------------------
//      Miscellaneous
//-------------------------------

EOF 
  = !.
  / c:. #ERROR{ string.Format("Line {0}; Column{1}: Unexpected character {2}", cStart.Line, cStart.Column ,c) }